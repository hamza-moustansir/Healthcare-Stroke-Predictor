{"ast":null,"code":"import { deepExtend, errorPrefix, getDistance, getDistances, getRandom, isArray, isString, itemFromArray } from \"tsparticles-engine\";\nimport { calcClosestPtOnSegment, drawPolygonMask, drawPolygonMaskPath, parsePaths, segmentBounce } from \"./utils\";\nconst noPolygonDataLoaded = `${errorPrefix} No polygon data loaded.`,\n  noPolygonFound = `${errorPrefix} No polygon found, you need to specify SVG url in config.`;\nexport class PolygonMaskInstance {\n  constructor(container, engine) {\n    this._checkInsidePolygon = position => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options?.enable || options.type === \"none\" || options.type === \"inline\") {\n        return true;\n      }\n      if (!this.raw) {\n        throw new Error(noPolygonFound);\n      }\n      const canvasSize = container.canvas.size,\n        x = position?.x ?? getRandom() * canvasSize.width,\n        y = position?.y ?? getRandom() * canvasSize.height;\n      let inside = false;\n      for (let i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {\n        const pi = this.raw[i],\n          pj = this.raw[j],\n          intersect = pi.y > y !== pj.y > y && x < (pj.x - pi.x) * (y - pi.y) / (pj.y - pi.y) + pi.x;\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n      return options.type === \"inside\" ? inside : options.type === \"outside\" ? !inside : false;\n    };\n    this._createPath2D = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options || !this.paths?.length) {\n        return;\n      }\n      for (const path of this.paths) {\n        const pathData = path.element?.getAttribute(\"d\");\n        if (pathData) {\n          const path2d = new Path2D(pathData),\n            matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix(),\n            finalPath = new Path2D(),\n            transform = matrix.scale(this._scale);\n          if (finalPath.addPath) {\n            finalPath.addPath(path2d, transform);\n            path.path2d = finalPath;\n          } else {\n            delete path.path2d;\n          }\n        } else {\n          delete path.path2d;\n        }\n        if (path.path2d || !this.raw) {\n          continue;\n        }\n        path.path2d = new Path2D();\n        path.path2d.moveTo(this.raw[0].x, this.raw[0].y);\n        this.raw.forEach((pos, i) => {\n          if (i > 0) {\n            path.path2d?.lineTo(pos.x, pos.y);\n          }\n        });\n        path.path2d.closePath();\n      }\n    };\n    this._downloadSvgPath = async (svgUrl, force) => {\n      const options = this._container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      const url = svgUrl || options.url,\n        forceDownload = force ?? false;\n      if (!url || this.paths !== undefined && !forceDownload) {\n        return this.raw;\n      }\n      const req = await fetch(url);\n      if (!req.ok) {\n        throw new Error(`${errorPrefix} occurred during polygon mask download`);\n      }\n      return this._parseSvgPath(await req.text(), force);\n    };\n    this._drawPoints = () => {\n      if (!this.raw) {\n        return;\n      }\n      for (const item of this.raw) {\n        this._container.particles.addParticle({\n          x: item.x,\n          y: item.y\n        });\n      }\n    };\n    this._getEquidistantPointByIndex = index => {\n      const container = this._container,\n        options = container.actualOptions,\n        polygonMaskOptions = options.polygon;\n      if (!polygonMaskOptions) {\n        return;\n      }\n      if (!this.raw || !this.raw.length || !this.paths?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      let offset = 0,\n        point;\n      const totalLength = this.paths.reduce((tot, path) => tot + path.length, 0),\n        distance = totalLength / options.particles.number.value;\n      for (const path of this.paths) {\n        const pathDistance = distance * index - offset;\n        if (pathDistance <= path.length) {\n          point = path.element.getPointAtLength(pathDistance);\n          break;\n        } else {\n          offset += path.length;\n        }\n      }\n      const scale = this._scale;\n      return {\n        x: (point?.x ?? 0) * scale + (this.offset?.x ?? 0),\n        y: (point?.y ?? 0) * scale + (this.offset?.y ?? 0)\n      };\n    };\n    this._getPointByIndex = index => {\n      if (!this.raw || !this.raw.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const coords = this.raw[index % this.raw.length];\n      return {\n        x: coords.x,\n        y: coords.y\n      };\n    };\n    this._getRandomPoint = () => {\n      if (!this.raw || !this.raw.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const coords = itemFromArray(this.raw);\n      return {\n        x: coords.x,\n        y: coords.y\n      };\n    };\n    this._getRandomPointByLength = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      if (!this.raw || !this.raw.length || !this.paths?.length) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const path = itemFromArray(this.paths),\n        distance = Math.floor(getRandom() * path.length) + 1,\n        point = path.element.getPointAtLength(distance),\n        scale = this._scale;\n      return {\n        x: point.x * scale + (this.offset?.x || 0),\n        y: point.y * scale + (this.offset?.y || 0)\n      };\n    };\n    this._initRawData = async force => {\n      const options = this._container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      if (options.url) {\n        this.raw = await this._downloadSvgPath(options.url, force);\n      } else if (options.data) {\n        const data = options.data;\n        let svg;\n        if (isString(data)) {\n          svg = data;\n        } else {\n          const getPath = p => `<path d=\"${p}\" />`,\n            path = isArray(data.path) ? data.path.map(getPath).join(\"\") : getPath(data.path);\n          const namespaces = 'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n          svg = `<svg ${namespaces} width=\"${data.size.width}\" height=\"${data.size.height}\">${path}</svg>`;\n        }\n        this.raw = this._parseSvgPath(svg, force);\n      }\n      this._createPath2D();\n      this._engine.dispatchEvent(\"polygonMaskLoaded\", {\n        container: this._container\n      });\n    };\n    this._parseSvgPath = (xml, force) => {\n      const forceDownload = force ?? false;\n      if (this.paths !== undefined && !forceDownload) {\n        return this.raw;\n      }\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      const parser = new DOMParser(),\n        doc = parser.parseFromString(xml, \"image/svg+xml\"),\n        svg = doc.getElementsByTagName(\"svg\")[0];\n      let svgPaths = svg.getElementsByTagName(\"path\");\n      if (!svgPaths.length) {\n        svgPaths = doc.getElementsByTagName(\"path\");\n      }\n      this.paths = [];\n      for (let i = 0; i < svgPaths.length; i++) {\n        const path = svgPaths.item(i);\n        if (path) {\n          this.paths.push({\n            element: path,\n            length: path.getTotalLength()\n          });\n        }\n      }\n      const scale = this._scale;\n      this.dimension.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\") * scale;\n      this.dimension.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\") * scale;\n      const position = options.position ?? {\n          x: 50,\n          y: 50\n        },\n        canvasSize = container.canvas.size;\n      this.offset = {\n        x: canvasSize.width * position.x / 100 - this.dimension.width / 2,\n        y: canvasSize.height * position.y / 100 - this.dimension.height / 2\n      };\n      return parsePaths(this.paths, scale, this.offset);\n    };\n    this._polygonBounce = (particle, _delta, direction) => {\n      const options = this._container.actualOptions.polygon;\n      if (!this.raw || !options?.enable || direction !== \"top\") {\n        return false;\n      }\n      if (options.type === \"inside\" || options.type === \"outside\") {\n        let closest, dx, dy;\n        const pos = particle.getPosition(),\n          radius = particle.getRadius();\n        for (let i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {\n          const pi = this.raw[i],\n            pj = this.raw[j];\n          closest = calcClosestPtOnSegment(pi, pj, pos);\n          const dist = getDistances(pos, closest);\n          [dx, dy] = [dist.dx, dist.dy];\n          if (dist.distance < radius) {\n            segmentBounce(pi, pj, particle.velocity);\n            return true;\n          }\n        }\n        if (closest && dx !== undefined && dy !== undefined && !this._checkInsidePolygon(pos)) {\n          const factor = {\n              x: 1,\n              y: 1\n            },\n            diameter = radius * 2;\n          if (pos.x >= closest.x) {\n            factor.x = -1;\n          }\n          if (pos.y >= closest.y) {\n            factor.y = -1;\n          }\n          particle.position.x = closest.x + diameter * factor.x;\n          particle.position.y = closest.y + diameter * factor.y;\n          particle.velocity.mult(-1);\n          return true;\n        }\n      } else if (options.type === \"inline\" && particle.initialPosition) {\n        const dist = getDistance(particle.initialPosition, particle.getPosition()),\n          {\n            velocity\n          } = particle;\n        if (dist > this._moveRadius) {\n          velocity.x = velocity.y / 2 - velocity.x;\n          velocity.y = velocity.x / 2 - velocity.y;\n          return true;\n        }\n      }\n      return false;\n    };\n    this._randomPoint = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      let position;\n      if (options.type === \"inline\") {\n        switch (options.inline.arrangement) {\n          case \"random-point\":\n            position = this._getRandomPoint();\n            break;\n          case \"random-length\":\n            position = this._getRandomPointByLength();\n            break;\n          case \"equidistant\":\n            position = this._getEquidistantPointByIndex(container.particles.count);\n            break;\n          case \"one-per-point\":\n          case \"per-point\":\n          default:\n            position = this._getPointByIndex(container.particles.count);\n        }\n      } else {\n        const canvasSize = container.canvas.size;\n        position = {\n          x: getRandom() * canvasSize.width,\n          y: getRandom() * canvasSize.height\n        };\n      }\n      if (this._checkInsidePolygon(position)) {\n        return position;\n      } else {\n        return this._randomPoint();\n      }\n    };\n    this._container = container;\n    this._engine = engine;\n    this.dimension = {\n      height: 0,\n      width: 0\n    };\n    this._moveRadius = 0;\n    this._scale = 1;\n  }\n  clickPositionValid(position) {\n    const options = this._container.actualOptions.polygon;\n    return !!options?.enable && options.type !== \"none\" && options.type !== \"inline\" && this._checkInsidePolygon(position);\n  }\n  draw(context) {\n    if (!this.paths?.length) {\n      return;\n    }\n    const options = this._container.actualOptions.polygon;\n    if (!options?.enable) {\n      return;\n    }\n    const polygonDraw = options.draw;\n    if (!polygonDraw.enable) {\n      return;\n    }\n    const rawData = this.raw;\n    for (const path of this.paths) {\n      const path2d = path.path2d;\n      if (!context) {\n        continue;\n      }\n      if (path2d && this.offset) {\n        drawPolygonMaskPath(context, path2d, polygonDraw.stroke, this.offset);\n      } else if (rawData) {\n        drawPolygonMask(context, rawData, polygonDraw.stroke);\n      }\n    }\n  }\n  async init() {\n    const container = this._container,\n      polygonMaskOptions = container.actualOptions.polygon,\n      pxRatio = container.retina.pixelRatio;\n    if (!polygonMaskOptions) {\n      return;\n    }\n    this._moveRadius = polygonMaskOptions.move.radius * pxRatio;\n    this._scale = polygonMaskOptions.scale * pxRatio;\n    if (polygonMaskOptions.enable) {\n      await this._initRawData();\n    }\n  }\n  particleBounce(particle, delta, direction) {\n    return this._polygonBounce(particle, delta, direction);\n  }\n  particlePosition(position) {\n    const options = this._container.actualOptions.polygon;\n    if (!(options?.enable && (this.raw?.length ?? 0) > 0)) {\n      return;\n    }\n    return deepExtend({}, position ? position : this._randomPoint());\n  }\n  particlesInitialization() {\n    const options = this._container.actualOptions.polygon;\n    if (options?.enable && options.type === \"inline\" && (options.inline.arrangement === \"one-per-point\" || options.inline.arrangement === \"per-point\")) {\n      this._drawPoints();\n      return true;\n    }\n    return false;\n  }\n  resize() {\n    const container = this._container,\n      options = container.actualOptions.polygon;\n    if (!(options?.enable && options.type !== \"none\")) {\n      return;\n    }\n    if (this.redrawTimeout) {\n      clearTimeout(this.redrawTimeout);\n    }\n    this.redrawTimeout = window.setTimeout(async () => {\n      await this._initRawData(true);\n      await container.particles.redraw();\n    }, 250);\n  }\n  stop() {\n    delete this.raw;\n    delete this.paths;\n  }\n}","map":{"version":3,"names":["deepExtend","errorPrefix","getDistance","getDistances","getRandom","isArray","isString","itemFromArray","calcClosestPtOnSegment","drawPolygonMask","drawPolygonMaskPath","parsePaths","segmentBounce","noPolygonDataLoaded","noPolygonFound","PolygonMaskInstance","constructor","container","engine","_checkInsidePolygon","position","_container","options","actualOptions","polygon","enable","type","raw","Error","canvasSize","canvas","size","x","width","y","height","inside","i","j","length","pi","pj","intersect","_createPath2D","paths","path","pathData","element","getAttribute","path2d","Path2D","matrix","document","createElementNS","createSVGMatrix","finalPath","transform","scale","_scale","addPath","moveTo","forEach","pos","lineTo","closePath","_downloadSvgPath","svgUrl","force","url","forceDownload","undefined","req","fetch","ok","_parseSvgPath","text","_drawPoints","item","particles","addParticle","_getEquidistantPointByIndex","index","polygonMaskOptions","offset","point","totalLength","reduce","tot","distance","number","value","pathDistance","getPointAtLength","_getPointByIndex","coords","_getRandomPoint","_getRandomPointByLength","Math","floor","_initRawData","data","svg","getPath","p","map","join","namespaces","_engine","dispatchEvent","xml","parser","DOMParser","doc","parseFromString","getElementsByTagName","svgPaths","push","getTotalLength","dimension","parseFloat","_polygonBounce","particle","_delta","direction","closest","dx","dy","getPosition","radius","getRadius","dist","velocity","factor","diameter","mult","initialPosition","_moveRadius","_randomPoint","inline","arrangement","count","clickPositionValid","draw","context","polygonDraw","rawData","stroke","init","pxRatio","retina","pixelRatio","move","particleBounce","delta","particlePosition","particlesInitialization","resize","redrawTimeout","clearTimeout","window","setTimeout","redraw","stop"],"sources":["C:/Users/hamza/OneDrive/Bureau/test/frontend/node_modules/tsparticles-plugin-polygon-mask/esm/PolygonMaskInstance.js"],"sourcesContent":["import { deepExtend, errorPrefix, getDistance, getDistances, getRandom, isArray, isString, itemFromArray, } from \"tsparticles-engine\";\nimport { calcClosestPtOnSegment, drawPolygonMask, drawPolygonMaskPath, parsePaths, segmentBounce } from \"./utils\";\nconst noPolygonDataLoaded = `${errorPrefix} No polygon data loaded.`, noPolygonFound = `${errorPrefix} No polygon found, you need to specify SVG url in config.`;\nexport class PolygonMaskInstance {\n    constructor(container, engine) {\n        this._checkInsidePolygon = (position) => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options?.enable || options.type === \"none\" || options.type === \"inline\") {\n                return true;\n            }\n            if (!this.raw) {\n                throw new Error(noPolygonFound);\n            }\n            const canvasSize = container.canvas.size, x = position?.x ?? getRandom() * canvasSize.width, y = position?.y ?? getRandom() * canvasSize.height;\n            let inside = false;\n            for (let i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {\n                const pi = this.raw[i], pj = this.raw[j], intersect = pi.y > y !== pj.y > y && x < ((pj.x - pi.x) * (y - pi.y)) / (pj.y - pi.y) + pi.x;\n                if (intersect) {\n                    inside = !inside;\n                }\n            }\n            return options.type === \"inside\"\n                ? inside\n                : options.type === \"outside\"\n                    ? !inside\n                    : false;\n        };\n        this._createPath2D = () => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options || !this.paths?.length) {\n                return;\n            }\n            for (const path of this.paths) {\n                const pathData = path.element?.getAttribute(\"d\");\n                if (pathData) {\n                    const path2d = new Path2D(pathData), matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix(), finalPath = new Path2D(), transform = matrix.scale(this._scale);\n                    if (finalPath.addPath) {\n                        finalPath.addPath(path2d, transform);\n                        path.path2d = finalPath;\n                    }\n                    else {\n                        delete path.path2d;\n                    }\n                }\n                else {\n                    delete path.path2d;\n                }\n                if (path.path2d || !this.raw) {\n                    continue;\n                }\n                path.path2d = new Path2D();\n                path.path2d.moveTo(this.raw[0].x, this.raw[0].y);\n                this.raw.forEach((pos, i) => {\n                    if (i > 0) {\n                        path.path2d?.lineTo(pos.x, pos.y);\n                    }\n                });\n                path.path2d.closePath();\n            }\n        };\n        this._downloadSvgPath = async (svgUrl, force) => {\n            const options = this._container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            const url = svgUrl || options.url, forceDownload = force ?? false;\n            if (!url || (this.paths !== undefined && !forceDownload)) {\n                return this.raw;\n            }\n            const req = await fetch(url);\n            if (!req.ok) {\n                throw new Error(`${errorPrefix} occurred during polygon mask download`);\n            }\n            return this._parseSvgPath(await req.text(), force);\n        };\n        this._drawPoints = () => {\n            if (!this.raw) {\n                return;\n            }\n            for (const item of this.raw) {\n                this._container.particles.addParticle({\n                    x: item.x,\n                    y: item.y,\n                });\n            }\n        };\n        this._getEquidistantPointByIndex = (index) => {\n            const container = this._container, options = container.actualOptions, polygonMaskOptions = options.polygon;\n            if (!polygonMaskOptions) {\n                return;\n            }\n            if (!this.raw || !this.raw.length || !this.paths?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            let offset = 0, point;\n            const totalLength = this.paths.reduce((tot, path) => tot + path.length, 0), distance = totalLength / options.particles.number.value;\n            for (const path of this.paths) {\n                const pathDistance = distance * index - offset;\n                if (pathDistance <= path.length) {\n                    point = path.element.getPointAtLength(pathDistance);\n                    break;\n                }\n                else {\n                    offset += path.length;\n                }\n            }\n            const scale = this._scale;\n            return {\n                x: (point?.x ?? 0) * scale + (this.offset?.x ?? 0),\n                y: (point?.y ?? 0) * scale + (this.offset?.y ?? 0),\n            };\n        };\n        this._getPointByIndex = (index) => {\n            if (!this.raw || !this.raw.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            const coords = this.raw[index % this.raw.length];\n            return {\n                x: coords.x,\n                y: coords.y,\n            };\n        };\n        this._getRandomPoint = () => {\n            if (!this.raw || !this.raw.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            const coords = itemFromArray(this.raw);\n            return {\n                x: coords.x,\n                y: coords.y,\n            };\n        };\n        this._getRandomPointByLength = () => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            if (!this.raw || !this.raw.length || !this.paths?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            const path = itemFromArray(this.paths), distance = Math.floor(getRandom() * path.length) + 1, point = path.element.getPointAtLength(distance), scale = this._scale;\n            return {\n                x: point.x * scale + (this.offset?.x || 0),\n                y: point.y * scale + (this.offset?.y || 0),\n            };\n        };\n        this._initRawData = async (force) => {\n            const options = this._container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            if (options.url) {\n                this.raw = await this._downloadSvgPath(options.url, force);\n            }\n            else if (options.data) {\n                const data = options.data;\n                let svg;\n                if (isString(data)) {\n                    svg = data;\n                }\n                else {\n                    const getPath = (p) => `<path d=\"${p}\" />`, path = isArray(data.path) ? data.path.map(getPath).join(\"\") : getPath(data.path);\n                    const namespaces = 'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n                    svg = `<svg ${namespaces} width=\"${data.size.width}\" height=\"${data.size.height}\">${path}</svg>`;\n                }\n                this.raw = this._parseSvgPath(svg, force);\n            }\n            this._createPath2D();\n            this._engine.dispatchEvent(\"polygonMaskLoaded\", {\n                container: this._container,\n            });\n        };\n        this._parseSvgPath = (xml, force) => {\n            const forceDownload = force ?? false;\n            if (this.paths !== undefined && !forceDownload) {\n                return this.raw;\n            }\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            const parser = new DOMParser(), doc = parser.parseFromString(xml, \"image/svg+xml\"), svg = doc.getElementsByTagName(\"svg\")[0];\n            let svgPaths = svg.getElementsByTagName(\"path\");\n            if (!svgPaths.length) {\n                svgPaths = doc.getElementsByTagName(\"path\");\n            }\n            this.paths = [];\n            for (let i = 0; i < svgPaths.length; i++) {\n                const path = svgPaths.item(i);\n                if (path) {\n                    this.paths.push({\n                        element: path,\n                        length: path.getTotalLength(),\n                    });\n                }\n            }\n            const scale = this._scale;\n            this.dimension.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\") * scale;\n            this.dimension.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\") * scale;\n            const position = options.position ?? {\n                x: 50,\n                y: 50,\n            }, canvasSize = container.canvas.size;\n            this.offset = {\n                x: (canvasSize.width * position.x) / 100 - this.dimension.width / 2,\n                y: (canvasSize.height * position.y) / 100 - this.dimension.height / 2,\n            };\n            return parsePaths(this.paths, scale, this.offset);\n        };\n        this._polygonBounce = (particle, _delta, direction) => {\n            const options = this._container.actualOptions.polygon;\n            if (!this.raw || !options?.enable || direction !== \"top\") {\n                return false;\n            }\n            if (options.type === \"inside\" || options.type === \"outside\") {\n                let closest, dx, dy;\n                const pos = particle.getPosition(), radius = particle.getRadius();\n                for (let i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {\n                    const pi = this.raw[i], pj = this.raw[j];\n                    closest = calcClosestPtOnSegment(pi, pj, pos);\n                    const dist = getDistances(pos, closest);\n                    [dx, dy] = [dist.dx, dist.dy];\n                    if (dist.distance < radius) {\n                        segmentBounce(pi, pj, particle.velocity);\n                        return true;\n                    }\n                }\n                if (closest && dx !== undefined && dy !== undefined && !this._checkInsidePolygon(pos)) {\n                    const factor = { x: 1, y: 1 }, diameter = radius * 2;\n                    if (pos.x >= closest.x) {\n                        factor.x = -1;\n                    }\n                    if (pos.y >= closest.y) {\n                        factor.y = -1;\n                    }\n                    particle.position.x = closest.x + diameter * factor.x;\n                    particle.position.y = closest.y + diameter * factor.y;\n                    particle.velocity.mult(-1);\n                    return true;\n                }\n            }\n            else if (options.type === \"inline\" && particle.initialPosition) {\n                const dist = getDistance(particle.initialPosition, particle.getPosition()), { velocity } = particle;\n                if (dist > this._moveRadius) {\n                    velocity.x = velocity.y / 2 - velocity.x;\n                    velocity.y = velocity.x / 2 - velocity.y;\n                    return true;\n                }\n            }\n            return false;\n        };\n        this._randomPoint = () => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            let position;\n            if (options.type === \"inline\") {\n                switch (options.inline.arrangement) {\n                    case \"random-point\":\n                        position = this._getRandomPoint();\n                        break;\n                    case \"random-length\":\n                        position = this._getRandomPointByLength();\n                        break;\n                    case \"equidistant\":\n                        position = this._getEquidistantPointByIndex(container.particles.count);\n                        break;\n                    case \"one-per-point\":\n                    case \"per-point\":\n                    default:\n                        position = this._getPointByIndex(container.particles.count);\n                }\n            }\n            else {\n                const canvasSize = container.canvas.size;\n                position = {\n                    x: getRandom() * canvasSize.width,\n                    y: getRandom() * canvasSize.height,\n                };\n            }\n            if (this._checkInsidePolygon(position)) {\n                return position;\n            }\n            else {\n                return this._randomPoint();\n            }\n        };\n        this._container = container;\n        this._engine = engine;\n        this.dimension = {\n            height: 0,\n            width: 0,\n        };\n        this._moveRadius = 0;\n        this._scale = 1;\n    }\n    clickPositionValid(position) {\n        const options = this._container.actualOptions.polygon;\n        return (!!options?.enable &&\n            options.type !== \"none\" &&\n            options.type !== \"inline\" &&\n            this._checkInsidePolygon(position));\n    }\n    draw(context) {\n        if (!this.paths?.length) {\n            return;\n        }\n        const options = this._container.actualOptions.polygon;\n        if (!options?.enable) {\n            return;\n        }\n        const polygonDraw = options.draw;\n        if (!polygonDraw.enable) {\n            return;\n        }\n        const rawData = this.raw;\n        for (const path of this.paths) {\n            const path2d = path.path2d;\n            if (!context) {\n                continue;\n            }\n            if (path2d && this.offset) {\n                drawPolygonMaskPath(context, path2d, polygonDraw.stroke, this.offset);\n            }\n            else if (rawData) {\n                drawPolygonMask(context, rawData, polygonDraw.stroke);\n            }\n        }\n    }\n    async init() {\n        const container = this._container, polygonMaskOptions = container.actualOptions.polygon, pxRatio = container.retina.pixelRatio;\n        if (!polygonMaskOptions) {\n            return;\n        }\n        this._moveRadius = polygonMaskOptions.move.radius * pxRatio;\n        this._scale = polygonMaskOptions.scale * pxRatio;\n        if (polygonMaskOptions.enable) {\n            await this._initRawData();\n        }\n    }\n    particleBounce(particle, delta, direction) {\n        return this._polygonBounce(particle, delta, direction);\n    }\n    particlePosition(position) {\n        const options = this._container.actualOptions.polygon;\n        if (!(options?.enable && (this.raw?.length ?? 0) > 0)) {\n            return;\n        }\n        return deepExtend({}, position ? position : this._randomPoint());\n    }\n    particlesInitialization() {\n        const options = this._container.actualOptions.polygon;\n        if (options?.enable &&\n            options.type === \"inline\" &&\n            (options.inline.arrangement === \"one-per-point\" ||\n                options.inline.arrangement === \"per-point\")) {\n            this._drawPoints();\n            return true;\n        }\n        return false;\n    }\n    resize() {\n        const container = this._container, options = container.actualOptions.polygon;\n        if (!(options?.enable && options.type !== \"none\")) {\n            return;\n        }\n        if (this.redrawTimeout) {\n            clearTimeout(this.redrawTimeout);\n        }\n        this.redrawTimeout = window.setTimeout(async () => {\n            await this._initRawData(true);\n            await container.particles.redraw();\n        }, 250);\n    }\n    stop() {\n        delete this.raw;\n        delete this.paths;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}